package Follow.Diary;

/*
 * Java笔记日记
 * */
public class Diary {
    // 2023年11月21日
    public void day1(String[] args) {
        // 爽爽等我1年，一定呀。
    }

    // 2023年11月22日
    public void day2(String[] args) {
		/*
		    今天看完了JavaSe基础语法
		    Java 的两大数据类型:
                内置数据类型：8个基本数据类型boolean char byte short int long double float
                引用数据类型
		*/
    }

    // 2023年11月23日
    public void day3(String[] args) {
        /*
         * idea破解
         * java的类和对象
         *
         * */
    }

    // 2023年11月24日
    public void day4(String[] args) {
        /*
         * 1.方法中传递的变量 形式参数也是局部变量，形式参数和方法里的局部变量 名称不能相同否则冲突
         * 2.如果形参和成员变量名称一样，需要用this指定谁是成员变量
         * 3.构造方法：名称需要和类名称一致，分为有参构造和无参构造，构造方法可以重载（方法名称相同，参数列表不同）
         *   类里没声明构造方法，系统会默认生成无参构造方法
         *   定义了有参构造方法，如果要使用无参构造方法，需要写一个无参构造方法
         *   例如Student类的构造方法写法为：
         *          public Student(){}
         *
         *  4.封装：
         *      通过private对类属性进行私有，拒绝外部访问，然后通过get/set方法，对属性的访问和修改进行控制。
         *  5.继承
         *
         * */
    }

    // 2023年11月25日
    public void day5() {
        /*
         *   1.继承的优点：复用，易维护。
         *       缺点：父子耦合，父改动了，子也会相应变化
         *   2.访问当前类方法 this.方法名();
         *       访问当前类成员变量 this.变量名称;
         *       访问当前类构造方法 this();
         *       访问父类方法 super.方法名();
         *       访问父类成员变量 super.变量名称;
         *       访问父类构造方法 super();
         *   3.子类实例化 调用子类构造方法前，默认必定会调用父类的无参构造方法，
         *       如果父类没定义无参构造方法但是定义了有参构造方法，然而子类定义了会报错。
         *       如果没定义有参无参构造方法，默认会有一个无参构造方法不会报错
         *       就相当于子类的构造方法不论有参无参第一句 默认执行了 super();
         *       如果父类不需要无参构造，但有有参构造，可以在子类构造的第一句用super(形参);访问有参父类构造方法，此时不会报错
         *   4.方法重写，在父类中声明过的方法，在子类中再次声明
         *        为什么要重写父类方法？ 因为子类中重写的方法是对父类方法的扩展延续升级迭代，延续了父类功能，又新定义了子类特有功能
         *           @override 作为重写的注解,可以检测方法是否可以重写
         *        方法重写 需要 方法名称和参数列表和父类一致，否则不能称作为方法重写
         *   5.访问修饰符：public
         *               private  此修饰的方法属性不能被子类继承，所以此类方法也不能被子类重写
         *               protected
         *               default 就是不写
         *           访问修饰符可以写在类上 方法上 变量上
         *           子类重写的方法访问权限不能比父类低  public > protected > default > private
         *    6.java中只能单继承不能多继承，可以多层继承， 爷爷>爸爸>儿子
         *     7.修改类名后用alt+enter快捷键修改引用到类名称的代码和文件名
         *     8.对着类名ctrl+alt+u可以查看继承关系图
         *
         *      9.package包的作用：
         *          包就相当于文件夹
         *          分类管理
         *          同样的文件名可以放在不同包里，但是同样的文件名不能在一个包里
         *          生产class文件 可以用 javac -d. ClassName.java 自动生成包目录
         *
         *      10.import
         *          import com.xxx.类名
         *          import com.xxx.* 代表com.xxx下的所有类
         *
         *      11.状态修饰符 final关键字 可以修饰类 成员方法 成员变量
         *          被final修饰的类无法被继承
         *          被final修饰的方法无法被重写
         *          被final修饰的变量值(必须有初始化值)无法被修改
         *          final修饰的局部变量是基本数据类型 修饰后无法改变
         *          final修饰的对象是引用类型 修饰后改对象的引用地址无法被修改，但是对象里的属性如果没被final修饰是可以修改的
         *
         *      12.通过static关键字修饰的  被类的所有对象共享访问
         *          static修饰的变量 可以直接用 类名.变量 访问
         *          static方法中 可以访问static方法，但是不能访问非static方法
         *          static方法中，可以访问static属性，但是不能访问非static属性
         *
         *      13.ctrl+shift+u 可以把切换选中代码大小写
         *          用 public static final 去定义常量，常量变量名称通常为大写
         *
         *      14.main方法
         *          是jvm在调用，访问权限必须是public 因为java虚拟机在调用类main方法时，不在同一个类
         *          java虚拟机调用main方法时不必创建对象，所以需要是static
         *          main方法接受String类型的数组 参数，执行java命令时传递给所执行类的参数
         *
         * */
    }

    // 2023年11月26日
    public void day6() {
        /*
         * 和锅盖一起去逛街了，买了鞋子和衣服，吃了火锅 喝了酒，然后去找她，唯一让我心里好受一点的是她被我逼出来见我了，这么久终于见了个面了
         *
         * */
    }

    // 2023年11月27日
    public void day7() {
        /*
         * 1.多态
         * 1.1要有继承关系
         * 1.2子类要对父类方法重写
         * 1.3要有父类引用指向子类对象
         *
         * 2.多态访问特点 （AnimalParent animalParent = new Cat();
         * 2.1成员变量编译看左边，执行看左边 （成员变量没有重写）
         * 2.2成员方法编译看左边，执行看右边（成员方法可以重写）
         *
         * 3.多态的优缺点
         * 3.1简化代码，易扩展，具体实现方法：通过父类类型作为参数接收，在使用时，使用具体的子类传递参与操作
         * 3.2如果子类存在父类没有的方法，则不能使用多态创建对象访问。也就是不能使用子类特有功能
         *
         * 4.抽象类
         * 4.1抽象类没有方法体，需要用abstract修饰类 和 方法，并且继承抽象类必须实现抽象父类抽象方法的重写
         * 4.2抽象类中可以写非抽象方法，非抽象方法子类不必须重写
         * 4.3定义的抽象类一定是一个抽象的概念，没有明确的事物，必须用子类来实例化
         * 4.4抽象类可以有构造方法，用于子类访问父类时的数据初始化
         *
         * */
    }

    // 2023年11月28日
    public void day8() {
        /*
         * 1.抽象关键字 abstract
         * 1.1abstract不能和关键字 private一起使用， 因为private修饰的方法不能被子类继承 abstract方法子类又必须重写
         * 1.2不能和关键字 final一起使用， 因为final定义的方法和变量无法修改，abstract方法子类必须重写
         * 1.3static，无意义，因为static方法可以直接用类名.方法 访问方法体。然而abstract方法没有方法体
         *
         * 2.接口 interface
         * 2.1接口是一种公共的规范，只要符合规范，大家都可以用，java中的接口更多体现在对行为的抽象
         * 2.2public interface 接口名{}
         * 2.3类实现接口用implement ，如 public class 类名 implement 接口名 {}
         * 2.4接口不能直接实例化
         * 2.5接口实例化需要参照多态的方式，也叫接口多态，通过实例化 实现类对象实现
         * 2.6多态的形式：具体类多态，抽象类多态，接口多态
         * 2.7多态的前提：有继承关系或者实现关系（类继承，接口实现）；有方法重写； 父（类/接口引用）指向（子类/接口实现类）对象
         * 2.8接口的实现类，要么重写所有接口的抽象方法，要么是抽象类
         * 2.9接口成员的特点
         * 2.9.1接口成员变量 默认加了 public static final 修饰 所以成员变量可以 直接写 int code = 200;
         * 2.9.2接口成员方法 默认加了 public abstract 修饰 所以成员方法可以直接 写 方法名(); (注意：在JDK8开始 可以加上default关键字 在接口中声明 非抽象方法)
         * 2.10接口是没有构造方法的，因为接口主要对行为进行抽象，没有具体存在，一个类如果没有父类，默认继承Object类
         *
         * 3.类和接口的关系区别
         * 3.1类 只能单继承类
         * 3.2类 可以实现多个接口
         * 3.3接口 可以继承多个接口
         *
         * 4.接口和抽象类的区别
         * 4.1成员区别，抽象类 可以有：构造方法，常量，变量，抽象方法，非抽象方法；  接口 有：常量，抽象方法， （JDK8以后可以定义非抽象方法）
         * 4.2设计区别：接口是对行为抽象，抽象类是对事物进行抽象，
         * 4.3更多的功能用接口去定义
         *
         * 5.内部类
         * 5.1 在一类中 定义一个类，这个类就是内部类，对应的 外面的就是外部内
         * 5.2 访问特点：内部类可以访问外部类的成员，包括私有， 外部类访问内部类的成员 需要先创建对象
         * 5.3 内部类分为 成员内部类（成员内部类，静态成员内部类） 局部内部类（方法内部类，匿名内部类）
         * 5.4 public内部类在 外界访问 格式 为： OuterObject.InnerObject = new OuterObject().new InnerObject();
         * 5.5 实际开发过程中，内部类不允许外界直接访问，需要用private修饰 内部类，然后在 外部类里定义方法去创建内部类对象
         * 5.6 public静态内部类 外界访问格式为:  OuterObject.InnerObject = new OuterObject.InnerObject();
         *       注意和静态方法访问一样，静态内部类中只能访问外部类的 静态属性 和静态方法
         * 5.6 局部内部类（方法内部类） 只能在方法里创建使用，并且也能访问外部内部类的 方法和属性，和方法内的局部变量
         * 5.7 匿名内部类 可以直接用 抽象类 和接口创建 new Anonymous() { 重写抽象方法 }， 接口和抽象类不能 实例化，但是匿名内部类的方式创建
         *       在底层做了处理。本质是一个继承了该类（子类） 或 实现了该接口（实现类）的匿名对象
         *       匿名内部类 应用场景：自动创建子类，减少创建子类，直接在逻辑层实现子类对抽象类或接口的方法重写
         * */
    }

    // 2023年11月29日
    public void day9() {
        /*
         * 方法的定义
         * idea的debug
         * 栈帧链
         *
         * */
    }

    // 2023年11月30日
    public void day10() {
        /*
         *   输出对象的原理 其实就是 拼接 对象的路径+对象名 +'@'+ 对象的hashCode到十六进制字符串
         * */
    }

    // 2023年12月1日
    public void day11() {
        /*
         *
         * */
    }

    // 2023年12月2日
    public void day12() {
        /*
         *   1.instanceof 返回 boolean类型
         *   1.1 对象的引用 instanceof 具体的类型（类or接口）是该类类型返回true（左边是右边的自身类，父类），不是返回false（左边是右边的子类，
         *           或者平级）
         *   1.2 instanceof 判断中， 编译时 父类，自身类，子类编译不会报错，但是如果没有关系的类型 例如创建一个非String对象后和String类型比较
         *           就会报错。
         *   1.3 应用场景，1想强转类型时，
         * */
    }

    // 2023年12月3日
    public void day13() {
        /*
         * 1.charAt 通过参数index返回字符串中index下标对应的字符
         * 2.replace 返回 替换 原字符串中的目标字符（串）替换成新的字符（串）后的新字符串,replaceFirst,replaceAll 返回 替换 匹配正则表达式
         * 的第一个（All是所有）后的新字符串
         * 3.单个字符和数字相加；'a'+10 = 107(97 + 10),底层是转换成二进制相加。ASCII（美国信息交换标准代码）
         * 4.indexOf("str") 查找str第一次出现的下标, indexOf("str", fromIndex) 第二个api是从某个index开始查询 字符串出现的index下标
         *          找不到返回 -1，indexOf 底层会把str转换成二进制，所以如果是查找字符，可以用十进制表示例如'a' 用97表示 indexOf(97)
         * 5.Java元空间；JDK1.8开始把方法区/永久代 改名 元空间。 JDK1.7开始 把字符串常量池 从方法区 转移到了 堆空间
         * 6.JDK1.9开始 String底层的char[] 改成了 byte[] 优化了JVM运行内存占用
         * 7.Math类（java.lang.Math），私有无参构造，不能new出对象。方法全是static修饰的
         * 8.工具类的设计思想
         * 8.1  构造方法私有化
         * 8.2  成员方法 public static 修饰
         * 9.基本数据类型包装类 Byte Short Integer Long Float Double Character Boolean
         *
         *
         *
         * */
    }

    public void day14() {
    }

    public void day15() {
    }

    // 2023年12月6日
    public void day16() {
        /*
         * 1.基本数据类型包装类
         * 1.1 基本数据类型存放在栈空间，包装类存放在堆空间
         * 1.2 sout输出包装类 不会得到对象内存地址，因为包装类都重写了toString方法，直接输出基本数据类型的值
         * 1.3 基本数据类型有对应的默认值，包装类默认是null
         *
         * 2.装箱和拆箱
         * 2.1装箱：将基本数据类型转换成包装类的过程
         * 2.2拆箱：将包装类转换成基本数据类型的过程
         * 2.3 Integer a = 60;//装箱， int b = a; //拆箱，装箱时自动调用Integer的valueOf，拆箱时自动调用intValue
         *
         * 3.Date    （精确到毫秒）
         * 3.1 Date()无参构造， 获取当前时间
         * 3.2 Date(long)有参构造，获取从标准基准时间 到 参数（毫秒）的时间
         * 3.3 date(实例化后的Date对象).setTime(long) 设置date从标准基准时间到 参数（毫秒）的时间
         * 3.4 date(实例化后的Date对象).getTime() 获取时间戳
         *
         * 4.simpleDateFormat
         * */
    }

    // 2023年12月7日
    public void day17() {
        /*
         * 1.dateUtils工具类设计
         *
         * 2.Calendar
         *
         * 3.异常 ： 如果不对异常做处理，jvm会默认将错误输出在控制台（异常名称，位置，原因等信息）
         * 3.1.异常分为两大类：编译时，运行时
         * 3.2.异常处理 try catch， 编译时异常 需要强制try catch， 运行时异常不需要强制try catch
         * 3.3.throws抛出异常，如果方法带有throws 异常类名， （属于运行时异常可以不用继续往上throws 或者写try catch）
         *           但是如果异常类名 不属于运行时异常 而是编译时异常 就必须写try catch，或者继续throws往上抛出异常），main方法再往上抛
         *           就抛给jvm虚拟机做处理了。
         * */
    }

    // 2023年12月8日
    public void day18() {
        /*
         *   1.集合框架组成部分
         *   1.1 Collection接口
         *          List接口（存放数据可以允许重复）
         *                   ArrayList 底层基于数组数据结构实现
         *                   LinkedList底层基于链表数据结构实现
         *           Set接口（存放数据不允许重复，去重方案）
         *                   HashSet 不允许重复，底层基于Map集合实现
         *
         *   1.2 Map接口
         *           HashMap 底层基于数组+链表实现（JDK1.7）， （JDK1.8后 基于数组+链表+红黑树实现）
         *           HashTable
         *
         *   2.ArrayList<泛型> 泛型只能是引用数据类型，不能用基本数据类型，例如可以用到Boolean ，Integer
         * */
    }

    // 2023年12月9日
    public void day19() {
        /*
         *   1.List 和 Collection
         *       List接口继承Collection接口
         *       Collection没有 get set方法，需要强转List后实现，因为多态成员方法编译看左边，运行看右边，
         *       Collection中 add 是直接往数组后面添加 对象， List 的add是往index位置添加对象，index后面如果有元素则所有往后有序排列。
         *
         *   2.for each循环(增强for循环) 底层基于Iterator迭代器实现
         *       for (类型 新变量名称:需要循环的变量名称) {}
         *
         *   3.泛型generics （JDK5引入）
         *       泛型就是：在编译阶段 限制了 数据类型就是泛型指定的类型，避免多种数据类型在类型转换时出现转换异常
         *       泛型类，泛型接口，泛型方法
         *       泛型只能是引用类型 例如 int不行，得用Integer
         * */
    }

    // 2023年12月10日
    public void day20() {
        /*
         * 泛型方法  public <E> E method(E e) {}
         *
         * 通配符：List<?> , 表示可以接受任意泛型类型， 但是不能用于add添加操作，可以做get查询操作，获取的类型是Object类型。
         *
         * 类型通配符上限：List<? extends 类型> 表示类型可以是类本身或者其子类类型
         * 类型通配符下限：List<? supper 类型>  表示类型可以是类本身或者其父类类型
         *
         * 1.可变参数
         *     method(int ... a)
         *       可变参数 底层是基于数组实现的，底层封装成数组传递给方法
         *       可变参数放到参数最后面
         *
         * 2.Arrays.asList创建的list集合， 可以修改不能删除和添加。
         *
         * 3.泛型的擦除机制
         *       泛型：在编译阶段限制传递的类型，运行阶段都是擦除的，底层class文件运行时是没有泛型概念的
         *
         * 4.ArrayList 与 Vector
         *       都是List接口下的子类，底层都是数组实现,Vector有参构造函数 可以设置初始数组容量（默认10）和扩容容量（默认是10）
         *       Vector线程安全，ArrayList线程不安全
         *
         * 5.链表数据结构      查询效率低（时间复杂度o(n)），增删效率高（时间复杂度 o(1)）
         *   单向链表，双向链表，
         *
         * 6.linkedList: 底层双链表实现
         *   底层实现 linkedList的查询，增加，删除操作
         * */
    }

    // 2023年12月11日
    public void day21() {
        /*
        * 1.Map接口 (集合）
        *      1.Map集合中key=>value 映射键值对
        *      2.Map集合中key不能重复，重复即修改value， value可以重复
        *      3.Map集合中HashMap 是散列存放数据的，遍历数据和存储顺序是不一致的--例如HashMap是无序的，LinkedHashMap是有序的。
        *      4.允许key值为null  位置 在 最前面 index = 0的链表
        * 2.Set接口
        *      1.HashSet 基于 HashMap实现，是通过HashMap的key值存放，所以hashSet不可以重复
        *      2.HashSet 是无序的 散列存放数据。
        *      3.同HashMap 允许值为null
        *      4.HashSet没有get方法
        *      5.HashSet中 如果存入对象， 需要对象重写 hashCode方法 和 equals方法。否则存入的对象因为引用地址不同会被认为是不同的key
        *         存入HashSet集合中
        *
        * 3.查看hashCode源码时 遇到的 & (java中的按位与（&）)
        *       按位与运算符（&）
                参加运算的两个数据，按二进制位进行“与”运算。

                运算规则：0&0=0;  0&1=0;   1&0=0;    1&1=1;

                      即：两位同时为“1”，结果才为“1”，否则为0

                例如：3&5  即 0000 0011& 0000 0101 = 00000001  因此，3&5的值得1
                ————————————————
                版权声明：本文为CSDN博主「ThinkPet」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
                原文链接：https://blog.csdn.net/ThinkPet/article/details/83546801
        *
        * 4. 3种获取HashMap中值的方法
        *       1.keySet获取keys foreach循环 再用get(key) 获取值
        *       2.entrySet()方法 获取 Set<Map.Entry<K, V>>类型, 再用此类型foreach对单个元素 用getKey 获取key，getValue获取值
        *       3.Iterator
        *
        * 5.集合处理
        *   重写equals方法 必须重写hashCode方法，因为Set存储的是不重复对象，依据equals和hashCode判断
        *   如果自定义对象为Map的键 也必须重写equals和hashCode方法
        *   如果equals方法比较两个对象相等，那么hashCode值一定相等
        *   但是两个对象hashCode相等，不代表equals方法比较也相等 （如果hashCode相等，equals不相等，就是 hash冲突）
        *
        * 6.HashMap存储时，根据key计算hash值 计算得到存储数组的index值
        *       hash冲突， 例如 key = a 和 key = 97 计算得到的 index值是相同的，所以存储按顺序 后面会覆盖前面的值
        *           解决hash冲突，在同一个index 使用链表 存放相同hash值的 数据， 往下链表形式添加
        *
        * */
    }

    //==================================================================================================================
    //=                                               JAVA IO流 学习                                                    =
    //==================================================================================================================

    // 2023年12月12日
    public void day22() {
        /*
         *   1.File
         *      创建，判断，获取
         *   2.递归
         *      自己调用自己。注意：栈有深度，会溢出（栈溢出），需要通过一些条件出栈
         * */
    }

    // 2023年12月13日
    public void day23(){

    }

    // 2023年12月14日
    public void day24(){

    }

    // 2023年12月15日
    public void day25(){

    }

    // 2023年12月16日
    public void day26(){

    }

    // 2023年12月17日
    public void day27(){

    }

    // 2023年12月18日
    public void day28(){
        /*
         * IO流
         *  FileOutputStream
         *  FileInputStream
         * */
    }
}